<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLUXza5VhXqVC6o75Eld_V98');ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Calibri";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c8{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Calibri";font-style:normal}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c10{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:700;text-decoration:underline;text-decoration-skip-ink:none;font-size:17pt;font-family:"Calibri"}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17pt;font-family:"Calibri";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c13{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{font-size:13pt;font-family:"Calibri";font-weight:400}.c12{font-size:17pt;font-family:"Calibri";font-weight:700}.c11{color:inherit;text-decoration:inherit}.c9{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c13 doc-content"><p class="c7"><span class="c4">Overview</span></p><p class="c3"><span class="c1">In this project we implemented bezier curves and their variations, and elementary mesh editions for more realistic shading and geometric objects. We first started by implementing basic bezier curves, and then moved on to bezier surfaces and approximating them with interpolation. Then we moved on with surfaces to area weighted vertex normals which provided smoother and better looking surfaces and introduced us to the halfedge data structure. In a similar vein we implemented edge flips, and then splits to modify the mesh and its topology. Finally we used upsampling where we upsampled the mesh and learnt more on topology. This project generally gave us a deeper understanding of geometric objects in a 3D space and their topologies.</span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c7"><span class="c4">Section I: Bezier Curves and Surfaces</span></p><p class="c7 c9"><span class="c4"></span></p><p class="c3"><span class="c8">Task 1: Bezier Curves with 1D de Casteljau Subdivision</span></p><p class="c3"><span class="c0">Casteljau&rsquo;s algorithm computes the position of points on a bezier curve that is parametrized by t. You basically break the curve into smaller segments, computing points on those segmentations, and then combining them all together for the final curve. The idea is to use linear interpolation to compute intermediate points on the curve, and then refining the approximation to create a smooth curve with a small number of control points. In the algorithm, we are given n +1 control points, so for each one we do linear interpolation with pi = (1-t)p +tpi with the p&rsquo;s being our points, and we just repeat it. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 328.92px; height: 218.97px;"><img alt="" src="images/image14.png" style="width: 328.92px; height: 218.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 343.58px; height: 228.50px;"><img alt="" src="images/image5.png" style="width: 343.58px; height: 228.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 347.47px; height: 228.86px;"><img alt="" src="images/image15.png" style="width: 347.47px; height: 228.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 341.50px; height: 225.48px;"><img alt="" src="images/image19.png" style="width: 341.50px; height: 225.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 338.50px; height: 223.50px;"><img alt="" src="images/image13.png" style="width: 338.50px; height: 223.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 352.14px; height: 232.50px;"><img alt="" src="images/image3.png" style="width: 352.14px; height: 232.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 347.45px; height: 233.86px;"><img alt="" src="images/image22.png" style="width: 347.45px; height: 233.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c8">Task 2: Bezier Surfaces with Separable 1D de Casteljau</span></p><p class="c3"><span class="c0">De castelijau&rsquo;s algorithm originally is used to calculate bezier curves, but it can also be used for bezier surfaces. The algorithm generally works by computing intermediate points until we find a on the curve. We extend this algorithm to work on a surface with a defined set of control points, so we compute the interpolation to get intermediate points from the control points columns until we arrive at a point on the surface. We specifically choose a parameter u and v from (0,1) and apply it to each row and column of De Casteljau&rsquo;s points. To get our g(u,v) we get a 2D array of control points evaluated at u, then we evaluating the &ldquo;sliding&rdquo; bezier curves across v, and thus can calculate and create objects using a patchwork of bezier surfaces.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 513.50px; height: 344.55px;"><img alt="" src="images/image8.png" style="width: 513.50px; height: 344.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c7"><span class="c4">Section II: Triangle Meshes and Half-Edge Data Structure</span></p><p class="c7 c9"><span class="c4"></span></p><p class="c3"><span class="c8">Task 3: Area-Weighted Vertex Normals</span></p><p class="c3"><span class="c0">Area weighted vertex normals are used in graphics to smooth surface normals for 3d models. The idea is to take the normal of each surface of the model, and then average them out to smooth. To implement this, we take the normals of the mesh by using the cross product of the edges of the surface. Then we compute the area of each surface, and add it using a weight to a sum vector, and normalize the norm to get our area weighted vertex normals. In this way larger faces will contribute more to the surface than smaller ones, and as a result creates a more visually appealing result.</span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 377.25px; height: 251.50px;"><img alt="" src="images/image6.png" style="width: 377.25px; height: 251.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 374.09px; height: 249.99px;"><img alt="" src="images/image7.png" style="width: 374.09px; height: 249.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c8">Task 4: Edge Flip</span></p><p class="c3"><span class="c0">The edge flip operation in 3D mesh processes transforms a given mesh into a new mesh via the modification of edges. It swaps a diagonal of the quadrilateral composed of two triangles by flipping with the other diagonal. </span></p><p class="c3"><span class="c1">The process first selects the triangle boundary that is not part of the mesh, and determines the vertices and edge in the triangles of such boundary. Then we compose a quadrilateral of the two triangles together and find the length of its diagonals. If </span><span class="c1">the would be flipped</span><span class="c0">&nbsp;diagonal is shorter than our current diagonal, we ignore it, and continue. In our implementation we got all the elements of the edge faces we were modifying and created a pointer to them. We ran into data loss errors, so even if we didn&rsquo;t modify an edge, we still created a pointer for it. Then we defined our half edges, faces, vertices and faces, and then updated each of them. We also, like the problem recommended, drew the problem out first before implementing it.</span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before: </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 370.73px; height: 252.50px;"><img alt="" src="images/image11.png" style="width: 370.73px; height: 252.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 375.50px; height: 248.53px;"><img alt="" src="images/image21.png" style="width: 375.50px; height: 248.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 366.68px; height: 239.17px;"><img alt="" src="images/image20.png" style="width: 366.68px; height: 239.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 418.98px; height: 279.99px;"><img alt="" src="images/image9.png" style="width: 418.98px; height: 279.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c8">Task 5: Edge Split </span></p><p class="c3"><span class="c0">An edge split algorithm transforms the original given mesh by modifying its edges through inserting a new vertex in the edge. The general operation is to, like task 4 (and its recommendations to avoid data loss), grab every vertex and edge and make pointers for them, and then split them. The boundary is a challenge, since we need to make sure the inserted point isn&rsquo;t outside of the boundary of the mesh, and we just project it in if it is. Then we update our mesh.</span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 378.50px; height: 256.58px;"><img alt="" src="images/image2.png" style="width: 378.50px; height: 256.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 378.63px; height: 249.99px;"><img alt="" src="images/image12.png" style="width: 378.63px; height: 249.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c8">Task 6: Loop Subdivision for Mesh Upsampling</span></p><p class="c3"><span class="c0">We implemented loop subdivision for upsampling by first computing all the vertices required for upsampling the mesh, and then precomputing the decimals rather than fractions in the formula for precomputing, and also the new vertices&rsquo; storage places in the newPosition field of old vertices. We should get a more accurate placement with decimals. Then we compute the updated vertex positions first, and then go and split every edge of the old mesh, where the old edge becomes the top edge, and the left and right are new edges. We then flip any edge that connects an old and new vertex together, and have an if statement to skip if it isn&rsquo;t. Then we copy positions, and we are done.</span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">In our upsampling, sharp corners and edges are smoothed over time, but it is possible to reduce this effect by pre-processing to keep some corners, primarily by splitting, but it changes the topology of the original object/mesh which sometimes could have adversarial effects.</span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c1">Our cube has asymmetrical topology, so it only makes sense that the resulting upsampling object will be asymmetrical as well. If we flip and split edges, we can create a symmetric object from a symmetric cube. By splitting the diagonals of the faces of the cube we can make it symmetric as shown, because each corner has the same degree. That cannot be accomplished with only flips to create a symmetric topology where each corner has the same symmetric degree. </span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 391.08px; height: 258.84px;"><img alt="" src="images/image24.png" style="width: 391.08px; height: 258.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 360.29px; height: 242.50px;"><img alt="" src="images/image17.png" style="width: 360.29px; height: 242.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 364.50px; height: 241.25px;"><img alt="" src="images/image23.png" style="width: 364.50px; height: 241.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 340.50px; height: 231.37px;"><img alt="" src="images/image4.png" style="width: 340.50px; height: 231.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 346.42px; height: 231.50px;"><img alt="" src="images/image18.png" style="width: 346.42px; height: 231.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">Before:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 350.83px; height: 233.33px;"><img alt="" src="images/image10.png" style="width: 350.83px; height: 233.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c0">After:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 363.75px; height: 242.50px;"><img alt="" src="images/image1.png" style="width: 363.75px; height: 242.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 368.38px; height: 250.50px;"><img alt="" src="images/image16.png" style="width: 368.38px; height: 250.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c3"><span class="c6">WEBPAGE:</span></p><p class="c3"><span class="c10"><a class="c11" href="https://www.google.com/url?q=https://kbeheshti.github.io/cs184-writeups/proj1/index.html&amp;sa=D&amp;source=editors&amp;ust=1677660257866907&amp;usg=AOvVaw1JJtAw4cYJ_RH-RXu941-I">https://kbeheshti.github.io/cs184-writeups/proj2/index.html</a></span><span class="c12">&nbsp;</span></p></body></html>