<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLUXza5VhXqVC6o75Eld_V98');ol{margin:0;padding:0}table td,table th{padding:0}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Calibri";font-style:normal}.c10{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:30pt;font-family:"Calibri";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Calibri";font-style:normal}.c5{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Calibri";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:25pt;font-family:"Calibri";font-style:normal}.c8{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Calibri"}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:17pt;font-family:"Calibri";font-style:italic}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c1{font-size:14pt;font-family:"Calibri";font-style:italic;font-weight:400}.c15{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c12{font-size:14pt;font-family:"Calibri";font-weight:700}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c2{font-size:14pt;font-family:"Calibri";font-weight:400}.c11{color:inherit;text-decoration:inherit}.c7{height:11pt}.c13{font-size:14pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><p class="c6"><span class="c10">2D Smoke Simulation</span></p><p class="c6"><span class="c16">Benjamin Feinberg, Tarek Soufi, Rahul Sudharsan, Kasra Beheshti</span></p><p class="c6 c7"><span class="c14"></span></p><p class="c6"><span class="c5">Summary</span></p><p class="c6"><span class="c0">For this project, we implemented 2D smoke simulation based on the suggested Navier-Stokes equation using Three.js and WebGL. We chose a web-based format to make distribution and presentation easier and allow us to focus more on the implementation of the shaders rather than the complexities of the underlying framework. We implemented settings to enable/disable shaders and show different slabs depending on the user&rsquo;s preference as well as smoke properties such as viscosity, velocity, and vorticity are modifiable to simulate different environments.</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c2">Our simulation can be found on a github pages site </span><span class="c2 c15"><a class="c11" href="https://www.google.com/url?q=https://rahulsudhu.github.io/colorful_smoke/&amp;sa=D&amp;source=editors&amp;ust=1683094835171059&amp;usg=AOvVaw0h1jiVITMWHrs-pTgRmMnA">here</a></span><span class="c0">.</span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c5">Theory</span></p><p class="c6"><span class="c0">The Navier-Stokes equation can be described as such:</span></p><p class="c6"><img src="images/image1.png"></p><p class="c6"><span class="c2">Where vector u is the velocity field, P is pressure, v is viscosity, and </span><span class="c13">&rho;</span><span class="c0">&nbsp;is the fluid density.</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c0">In our case, due to other conditions that need to be taken into account, such as external forces and boundary conditions, the Navier-Stokes equation is a baseline we have expanded upon to best simulate fluid in a bounded environment.</span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c5">Three.JS</span></p><p class="c6"><span class="c0">We decided to build our underlying framework using Three.JS. This was chosen as mentioned earlier due to the lower barrier-of-entry and the ability to test seamlessly from any OS platform. Although Three.JS is for 3D graphics, we have used a fixed orthographic camera to simulate a 2D plane for our smoke simulation. Our shaders are written in GLSL and loaded using an asynchronous shader loading operation in our framework that allows us to scale as necessary to include any new shaders with minimal changes to the framework. </span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c0">Operations performed by the fragment shader are rendered onto a WebGLRenderTarget which is then displayed to the scene. In WebGL, because a texture must either be a data source or rendering target, we cannot read/write to just one texture simultaneously. Therefore, for fluid properties we have chosen to simulate such as velocity, we have two textures, one for modifying and one for rendering changes. Once this operation is performed, the textures are swapped so the data used for the latest animation frame is now the source of the next operation. This process represents a &ldquo;slab operation,&rdquo; which Nvidia describes as the processing of all shader fragments on a frame buffer and the texture post-op process that involves the swapping operation. The &ldquo;slab&rdquo; itself can be thought of as the 2D plane (or buffer) that represents the fluid property we are simulating. Each fluid property is a separate slab.</span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c5">Problems Encountered</span></p><p class="c6"><span class="c0">We encountered quite a few problems during our initial setup phase. Initially, there was a sort of fundamental roadblock in bridging the gap between how the shaders worked in tandem with the buffers in Three.JS after the shaders were loaded. At times, certain coefficients we selected for different operations like diffusion or density caused weird paint-like effects that went contrary to our intended final result. Some of these can still be simulated by playing around with the settings and setting them to something wildly unrealistic. Once we further detailed how we want our scalability to work, we applied various framework fixes that made adding future shaders seamless and non-conflicting with calculations made by previous iterations of the animation loop. </span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c12">Shaders</span></p><p class="c6"><span class="c0">Not all of these ended up being an individual shader, some were combined into one to make the math calculations more streamlined versus broken up.</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c0">We first solved the mass conservation equation to update the density stored in the z coordinate of the velocity field using this equation: </span></p><p class="c6"><img src="images/image2.png"></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c0">We then compute velocity which is computed by summing the changes in velocity caused by viscous diffusion, an external force caused by mouse drags, and a corrective pressure field term to preserve null divergence.</span></p><p class="c6"><span class="c0">Viscous diffusion is computed by taking the Laplacian of the velocity and scaling with viscosity threshold. </span></p><p class="c6"><span class="c0">The external force is given from the distance from the texel coordinate to the mouse scaling the drag direction vector.</span></p><p class="c6"><span class="c0">Pressure can be computed by scaling the density gradient. </span></p><p class="c6"><span class="c0">We can then take the curl of the texel&rsquo;s velocity to get vorticity which adds small-scale detail to the fluid and normalize this value by the vorticity threshold parameter and add this to the fluid velocity. </span></p><p class="c6"><span class="c1">External boundary conditions</span><span class="c0">:</span></p><p class="c6"><span class="c0">To handle smoke hitting the boundaries of the box, during each animation step, the velocity of the particle in question was clamped in such a way that if the updated texture data would exceed the boundary cells making up the border, it would instead be reset to the boundary line and its velocity would be negated to simulate a collision. </span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c1">Advection</span></p><p class="c6"><span class="c0">To handle the dissipation of the texel information, we implemented the semi-lagrangian scheme which is cost-effective for the GPU to compute. Given the transport equation (modified for velocity): </span></p><p class="c6"><img src="images/image3.png"></p><p class="c6 c7"><span class="c4"></span></p><p class="c6"><span class="c0">We can solve for u at the current texel&rsquo;s position x using the formula:</span></p><p class="c6"><img src="images/image4.png"></p><p class="c6"><span class="c0">This formula takes the trajectory imputed from the current texture data to determine the state at the previous timestep and then calculate advection at the next timestep. </span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c1">External Forces</span></p><p class="c6"><span class="c0">External forces in this context are defined as forces simulated using the trajectory of the mouse input. In this case, a constant velocity was applied in the trajectory the mouse was traveling along to simulate smoke blowing out in that direction.</span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6 c7"><span class="c5"></span></p><p class="c6"><span class="c5">Video</span></p><p class="c6"><span class="c15 c2"><a class="c11" href="https://www.google.com/url?q=https://youtu.be/WSWKw1_Sbzc&amp;sa=D&amp;source=editors&amp;ust=1683094835546987&amp;usg=AOvVaw38TNRGV1xx6zzX-vHs8IOH">https://youtu.be/WSWKw1_Sbzc</a></span><span class="c0">&nbsp;</span></p><p class="c6 c7"><span class="c0"></span></p><hr><p class="c6 c7"><span class="c0"></span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c5">References</span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/lecture/20/fluid-simulation&amp;sa=D&amp;source=editors&amp;ust=1683094835547690&amp;usg=AOvVaw24jD8ZvhESWOnb6guauVAz">https://cs184.eecs.berkeley.edu/sp23/lecture/20/fluid-simulation</a></span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf&amp;sa=D&amp;source=editors&amp;ust=1683094835548052&amp;usg=AOvVaw0xBw8qQTcOZzDNqeg5eXCE">http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf</a></span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-38-fast-fluid-dynamics-simulation-gpu&amp;sa=D&amp;source=editors&amp;ust=1683094835548448&amp;usg=AOvVaw1B6xa8RHv30wuqdEMfeoQs">https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-38-fast-fluid-dynamics-simulation-gpu</a></span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=https://gamedevelopment.tutsplus.com/tutorials/how-to-write-a-smoke-shader--cms-25587&amp;sa=D&amp;source=editors&amp;ust=1683094835548798&amp;usg=AOvVaw2if1C0EuLaDel9HAI0dmiQ">https://gamedevelopment.tutsplus.com/tutorials/how-to-write-a-smoke-shader--cms-25587</a></span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=https://maths.ucd.ie/~plynch/LECTURE-NOTES/NWP-2004/NWP-CH03-2-6.pdf&amp;sa=D&amp;source=editors&amp;ust=1683094835549153&amp;usg=AOvVaw2C5tGeuV6kB4pq4WByMsgu">https://maths.ucd.ie/~plynch/LECTURE-NOTES/NWP-2004/NWP-CH03-2-6.pdf</a></span><span class="c3">&nbsp;</span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c8"><a class="c11" href="https://www.google.com/url?q=https://inria.hal.science/inria-00596050/document&amp;sa=D&amp;source=editors&amp;ust=1683094835549526&amp;usg=AOvVaw1nC1mwBO8dawHcX_gJbY8O">https://inria.hal.science/inria-00596050/document</a></span><span class="c3">&nbsp;</span></p><p class="c6 c7"><span class="c3"></span></p><hr><p class="c6 c7"><span class="c3"></span></p><p class="c6 c7"><span class="c3"></span></p><p class="c6"><span class="c12">Contributions</span></p><p class="c6"><span class="c1">Benjamin</span><span class="c0">: Underlying Three.JS framework &amp; asynchronous shader loading, frame buffer, shader debugging, GUI menu;</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c1">Rahul</span><span class="c0">: Fluid simulation shaders (advection, vorticity, density, etc), changes to velocity decay;</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c1">Tarek</span><span class="c0">: All the weird things, Bloom shader(hookah_lounge), &amp; milestone/final videos, final powerpoint slides and quirky design;</span></p><p class="c6 c7"><span class="c0"></span></p><p class="c6"><span class="c1">Kasra:</span><span class="c2">&nbsp;Framework for smoke visualization &amp; velocity operations, additions to GUI menu, user input, milestone report, final report;</span></p></body></html>