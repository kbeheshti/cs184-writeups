<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLUXza5VhXqVC6o75Eld_V98');.lst-kix_5ohq5wfggwrd-0>li:before{content:"\0025cf  "}ul.lst-kix_l3q07eiyaq7j-0{list-style-type:none}.lst-kix_5ohq5wfggwrd-1>li:before{content:"\0025cb  "}ul.lst-kix_l3q07eiyaq7j-1{list-style-type:none}.lst-kix_5ohq5wfggwrd-2>li:before{content:"\0025a0  "}ul.lst-kix_l3q07eiyaq7j-6{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-7{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-8{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-2{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-3{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-4{list-style-type:none}ul.lst-kix_l3q07eiyaq7j-5{list-style-type:none}.lst-kix_l3q07eiyaq7j-8>li:before{content:"\0025a0  "}.lst-kix_5ohq5wfggwrd-8>li:before{content:"\0025a0  "}.lst-kix_l3q07eiyaq7j-7>li:before{content:"\0025cb  "}.lst-kix_l3q07eiyaq7j-6>li:before{content:"\0025cf  "}.lst-kix_l3q07eiyaq7j-3>li:before{content:"\0025cf  "}.lst-kix_l3q07eiyaq7j-5>li:before{content:"\0025a0  "}.lst-kix_l3q07eiyaq7j-4>li:before{content:"\0025cb  "}.lst-kix_l3q07eiyaq7j-1>li:before{content:"\0025cb  "}.lst-kix_l3q07eiyaq7j-2>li:before{content:"\0025a0  "}.lst-kix_l3q07eiyaq7j-0>li:before{content:"\0025cf  "}ul.lst-kix_5ohq5wfggwrd-5{list-style-type:none}ul.lst-kix_5ohq5wfggwrd-6{list-style-type:none}.lst-kix_5ohq5wfggwrd-7>li:before{content:"\0025cb  "}ul.lst-kix_5ohq5wfggwrd-7{list-style-type:none}ul.lst-kix_5ohq5wfggwrd-8{list-style-type:none}ul.lst-kix_5ohq5wfggwrd-1{list-style-type:none}ul.lst-kix_5ohq5wfggwrd-2{list-style-type:none}.lst-kix_5ohq5wfggwrd-6>li:before{content:"\0025cf  "}ul.lst-kix_5ohq5wfggwrd-3{list-style-type:none}ul.lst-kix_5ohq5wfggwrd-4{list-style-type:none}.lst-kix_5ohq5wfggwrd-4>li:before{content:"\0025cb  "}.lst-kix_5ohq5wfggwrd-3>li:before{content:"\0025cf  "}.lst-kix_5ohq5wfggwrd-5>li:before{content:"\0025a0  "}ul.lst-kix_5ohq5wfggwrd-0{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;height:11pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Calibri";font-style:normal}.c15{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Calibri";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c7{font-size:13pt;font-family:"Calibri";font-style:italic;font-weight:400}.c8{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c5{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c10{font-size:13pt;font-family:"Calibri";font-weight:400}.c18{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c16{font-weight:400;font-size:14pt;font-family:"Calibri"}.c12{color:#000000;text-decoration:none;vertical-align:baseline}.c6{font-weight:700;font-size:17pt;font-family:"Calibri"}.c17{font-weight:400;font-size:11pt;font-family:"Calibri"}.c9{font-weight:400;font-size:15pt;font-family:"Calibri"}.c2{font-size:14pt;font-family:"Calibri";font-weight:700}.c14{color:inherit;text-decoration:inherit}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18 doc-content"><p class="c11"><span class="c3"></span></p><p class="c13"><span class="c3">Overview: </span></p><p class="c4"><span class="c1">This project is all about the basics of graphics, pixels and triangles and what they can accomplish. Our first objective is to determine if a point is in a triangle, the basic shape that makes all other polygons, and then expand on it to produce more beautiful looking shapes by being more accurate with where the lines intersect inside the pixels rather than the centers, as we assumed in the beginning. Then we divorce our implementation from the cartesian system, and move on to Barycentric coordinates that allow us to interpolate colors from a texture onto the shapes so they move together. We finally add layered textured capabilities to our project for shapes using mipmaps, and extract the color of each pixel depending on the mipmap filtering method used. This project in general is about how to efficiently represent image data on a screen using native methods to promote a greater understanding and experience of computer graphics</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c13"><span class="c3">Section I: Rasterization</span></p><p class="c11"><span class="c3"></span></p><p class="c4"><span class="c2">Task 1: Rasterizing single color triangles</span></p><p class="c4"><span class="c1">&nbsp;Rasterizing is essentially representing polygons in a model (ours is 2D), by first splitting polygons into triangles, and rasterizing those triangles since they are easier to work with, given they only lie on one plane, are simple shapes, and every single other polygon can be made of triangles. A rasterizer should not rasterize pixels more than once, and should only color a pixel if the center of the pixel is in the triangle or on the line boundary. So we need to compute if the center of a pixel is inside the 3 lines created by the edges created by the vertices of the triangle, and color that. We need to do this process because on a screen we only have a set amount of pixels, as compared to real life where it goes down to literal atoms. For example in real life a triangle cut out of paper properly would have all three sides be lines, which is not possible in a computer.The code process on how we implemented that is given below. </span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">Rasterizing triangles in code : We are provided with 3 sets of points and a color, and, in our code we first check if they are in the correct order after initializing the points as vectors. We then create lines from those points, and then calculate the normal vectors that point inwards for future use in determining if a point is in the triangle. We then take the minimum and maximum of each of the point&rsquo;s x&rsquo;s and y&rsquo;s so we can figure out our bounds. If we want better performance we can pre calculate the points that are in the triangle, ie following the line so we check less pixels. We then check every point in our bounds, which we decided to implement through nested for loops, check if the point in the center of the pixel is inside the triangle by doing the three line tests mentioned in the lecture, and coloring the pixel if it is inside the triangle.</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">Our project is no worse than one that checks each pixel in the bounding box of the triangle because that is what we did. We took the maximum of the x and y of all the points and the minimum and used that to bound where we can go in the triangle</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">Test 4: (Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.) </span></p><p class="c4"><span class="c1"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 383.50px; height: 306.68px;"><img alt="" src="images/image4.png" style="width: 383.50px; height: 306.68px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 377.91px; height: 301.81px;"><img alt="" src="images/image12.png" style="width: 377.91px; height: 301.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c15"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c2">Task 2: </span><span class="c2 c5">&nbsp;Antialiasing triangles</span></p><p class="c4"><span class="c1">One issue we run into in task 1 is the task of deciding if points on the fringe of the object/triangle, where the object&rsquo;s boundary lines run through them should be colored or not. Super sampling is a solution to that method where you sample more than once in the pixel by splitting the pixel into denser grids and average out the non inside line vs inside line to get a lighter color, giving less jaggies.<br></span></p><p class="c4"><span class="c1">Our first objective was to change the rasterize_triangle function to support supersampling by adding 2 nested for loops to run under the for loops that run through all the pixels in the triangle, to give us sqrt(supersampling rate) x sqrt(supersampling rate) and then create a new x and y of the place we are at in the for loop. Then we take those new x and y values and figure out if they are in the triangle and our pixel, then we color it by a shade, so if every part of the pixel, based on the super sampling points we take, is inside the triangle we color it fully.</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">Super sampling is a method used to reduce jaggies where in one pixel you sample a set number of times, and then calculate the number of times you were inside the shape given over the total to figure out the color that should be given to the object. The major data structure to accomplish this is vectors and our sample buffer. Super sampling is useful because it is simpler to implement, renders details on low-res screens more nicely and gives the image a higher quality and looks more natural. </span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">We modified the rasterizer function by placing a counter for supersampling in the for loop, then we modified fill_pixel to support supersampling by making it accept a count parameter. Then we changed the sample buffer to account for the increase in overall grid size and include the supersampled pixels, essentially making it the supersampling grid and allowing us to count along that grid. Then we average the values of the colors, and we are done.</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7 c12">Sample rate 1: &nbsp; </span></p><p class="c0"><span class="c7 c12"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 230.47px; height: 213.62px;"><img alt="" src="images/image2.png" style="width: 310.61px; height: 232.50px; margin-left: -80.14px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7">Sample rate 4:</span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c4"><span class="c1"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.83px; height: 221.62px;"><img alt="" src="images/image1.png" style="width: 321.14px; height: 240.87px; margin-left: -81.32px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7 c12">Sample rate: 16</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 219.50px; height: 203.92px;"><img alt="" src="images/image16.png" style="width: 294.55px; height: 220.92px; margin-left: -75.05px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">As we can see from the different sample rates, the edges become less pixelated as we increase the sample rate, and the edges get slightly blurred into softer colors, which makes the shapes look more realistic. For example, in the first image with sample rate 1, parts of the triangle are disconnected, while in sample rate 16 we don&rsquo;t have this issue, since as we reach that razor thin edge, the edge gets blurred. </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c2">Task 3</span><span class="c2">: Transformations and Groups</span></p><p class="c4"><span class="c1">He has to pee :) </span></p><p class="c4"><span class="c1">I basically had to bring the legs together to make it seem like he is holding his pee, then translate the legs apart so I could rotate them away from each other without them hitting each other and looking more natural. He now looks more anxious. Then I translated one hand and rotated it to go over where his legs came together like he was physically holding his pee in, and the other close by to make him seem like more of a mess now that he needs to pee, and shifted his face/head more down so he is all scrunch up together. I really like it&ndash;so animated and real.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 229.33px;"><img alt="" src="images/image10.png" style="width: 186.50px; height: 229.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c0"><span class="c3"></span></p><p class="c4"><span class="c3">Section II: Sampling</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c2">Task 4: Barycentric Coordinates</span></p><p class="c4"><span class="c1">Using Barycentric coordinates is a method to represent a point with respect to the geometry of what you are working with like a triangle, line, or if need be, a tetrahedron (triangle in 3d with triangles on all sides). The way it works is it tells you how far away you are from each point and their lines, and this allows you to interpolate between them. You use 3 weights for them all summing to one, ie alpha + beta + gamma = 1. Below we have a triangle with a red, blue, and green point, and then using barycentric coordinates, with those 3 points, we calculate the colors which gives us the triangle below. As we get farther from the blue point, we get less blue, and same with the red and green, and as we get closer to the color points, the color becomes stronger. This results in a vast array of colors, and a gradient effect giving us purple in between blue and red, yellow/orange in between green and red, and so on. In a similar manner, barycentric coordinates use the 3 points of the triangle to tell you where you are in the triangle.</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 165.69px; height: 143.82px;"><img alt="" src="images/image13.png" style="width: 165.69px; height: 143.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.09px; height: 255.75px;"><img alt="" src="images/image9.png" style="width: 322.09px; height: 255.75px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c10"><br></span><span class="c5 c2">Task 5: Pixel sampling for texture mapping</span></p><p class="c4"><span class="c1">Pixel Sampling: Like part 4 we use barycentric coordinates to take an (x,y) type of coordinates and map it to (x`,y`). This is useful because texture mapping is taking a texture of an object and mapping it on the object which may not always be the same size as the texture. To do pixel sampling in this case is determining the method in which to choose what color should be taken for the pixel undergoing this transformation. Choosing between pixel sampling methods in general is an attempt to make the final image we produce better, and can be used in instances when there is too much information for us to display, thus we reduce the information per pixel down to something that is computationally viable for our display .</span></p><p class="c4"><span class="c1">For nearest level pixel sampling, we take a normalized coordinate and round to the closest texels on the map and apply that to the pixel. For bilinear pixel sampling, we take the four nearest texels and interpolate them each twice along 2D axes to determine a color that best preserves the abnormalities of the mapped area. Bilinear sampling ultimately results in better image quality under magnification because it is not a 1:1 association of the pixel to the map. However, it is more computationally expensive.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7 c12">Nearest: 16 samples per pixel: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 samples per pixel</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 243.50px; height: 204.98px;"><img alt="" src="images/image8.png" style="width: 296.77px; height: 222.34px; margin-left: -53.27px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 240.84px; height: 202.73px;"><img alt="" src="images/image14.png" style="width: 293.52px; height: 220.22px; margin-left: -52.68px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7 c12">Bilinear:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 273.47px; height: 228.15px;"><img alt="" src="images/image7.png" style="width: 332.64px; height: 249.33px; margin-left: -59.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 282.05px; height: 239.55px;"><img alt="" src="images/image3.png" style="width: 344.42px; height: 258.52px; margin-left: -62.37px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">In our images, we can clearly see that bilinear mapping produces smoother looking latitude and longitude lines that connect as compared to nearest. The nearest also produces this effect where the line actually turns into a pattern of on and off and being sharp, rather than actually being a true line. The comparison in the 16 samples per pixel is far less stark and apparent, with the nearest sampling essentially equating to bilinear sampling, and only being slightly blurry. However without increasing the sampling rate, bilinear produces a more accurate and line looking latitude and longitude line.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c5 c2">Task 6: Level Sampling/mipmaps for texture mapping: </span></p><p class="c4"><span class="c1">Our first objective is to get the barycentric coordinates and those shifted by 1 in the x and y and get differentials at them to see how much the texture is shifting at our position. We then create the mipmap, and choose which to use, taking into account the change in coordinates when choosing, by taking their log to select the level.</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c1">Now lets compare the 3 parameters, pixel sampling, level sampling, and number of samples per pixel and their performance. In pixel sampling we have bilinear sampling and nearest sampling, with nearest just using round() to find the closest level, and bilinear level sampling making us go through the two closest levels to take a weighted average, both having similar enough memory usages with bilinear being less performant friendly. With this we can see bilinear sampling takes more compute time, since we need to take more samples, and perform more interpolations, but gives a slightly better image quality overall. Number of samples per pixel does not change the quality of the image by much if the image is large, and doesn&rsquo;t have important small details, which, for the most part, means it isn&rsquo;t too useful as it takes sample_rate more compute time than 1 sample per pixel, and more memory in sample buffer. For mipmaps, the higher the level the less storage needed to store the texture (only increasing by &#8531;), as well as render time and aliasing things. So bilinear is very good here since we are interpolating for the result and gives us less memory usage and time complexity, and mipmaps (in high level) work and scale very well in both those categories versus supersampling, which gives more data per pixel, but uses significantly more memory and time.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c7 c12">L_ZERO/P_NEAREST</span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 525.11px; height: 393.83px;"><img alt="" src="images/image6.png" style="width: 525.11px; height: 393.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c7 c12">L_ZERO/P_BILINEAR</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 538.50px; height: 403.88px;"><img alt="" src="images/image11.png" style="width: 538.50px; height: 403.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c7 c12">L_NEAREST/P_NEAREST</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 535.33px; height: 401.50px;"><img alt="" src="images/image5.png" style="width: 535.33px; height: 401.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c7">L_NEAREST/P_BILINEAR</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 525.56px; height: 394.17px;"><img alt="" src="images/image15.png" style="width: 525.56px; height: 394.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">The biggest difference between the images is whether the level sampling was level 0 or nearest level sampling, since they changed the shape of the collar for the snake, while the bilinear or nearest pixel sampling only slightly changed the shading, intricacies, and color on the collar of the snake. Nearest level sampling properly identified the intricate folds and details of the collar of the snake, whereas level 0 sampling failed to pick up that detail, and so the collar looks a bit flat. For the differences in the level 0 sampling with nearest pixel sampling and bilinear interpolation pixel sampling, the details aren&rsquo;t as apparent, and therefore there isn&rsquo;t much difference between them, but bilinear interpolation still has a few more details than nearest pixel sampling. For nearest level sampling, the difference between nearest pixel sampling and bilinear interpolation pixel sampling is far greater, with nearest pixel sampling appearing more granulated and rough, but less rough than level zero sampling, and bilinear pixel sampling being the most natural, soft, detailed, and overall best looking.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c2">Conclusion:</span></p><p class="c4"><span class="c10">Through the rasterization project, we implemented and covered much of the basic methods in graphics that deal with pixels. We started by coloring and rasterizing triangles, and moving on to making them look more realistic, despite the limitations of the computer only being able to manipulate pixels. We then moved on to transform and control a robot to any pose as we wanted. Finally we implemented pixel sampling methods and level sampling to produce more robust and smoother and more complex images like our imported snazzy snake. </span></p><p class="c0"><span class="c1"></span></p><p class="c4"><span class="c5 c6">WEBPAGE:</span></p><p class="c4"><span class="c6 c8"><a class="c14" href="https://www.google.com/url?q=https://kbeheshti.github.io/cs184-writeups/proj1/index.html&amp;sa=D&amp;source=editors&amp;ust=1676445446468216&amp;usg=AOvVaw3Vg6vVZKi4magr2R0SgIC4">https://kbeheshti.github.io/cs184-writeups/proj1/index.html</a></span><span class="c5 c6">&nbsp;</span></p></body></html>
