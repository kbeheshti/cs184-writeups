<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLUXza5VhXqVC6o75Eld_V98');ol{margin:0;padding:0}table td,table th{padding:0}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Calibri";font-style:normal}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Calibri";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{color:#000000;text-decoration:none;vertical-align:baseline;font-style:italic}.c7{font-size:15pt;font-family:"Calibri";font-weight:700}.c6{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{font-size:13pt;font-family:"Calibri";font-weight:400}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c6 doc-content"><p class="c9"><span class="c7">Overview</span></p><p class="c1"><span class="c2">In this project we learned how to implement methods that allow us to render very realistic and natural looking scenes. We started with a simple ray model, and built up to BVH trees and their intersections with rays. We then implemented direct and indirect lighting functions, and finished with adaptive sampling to allow us better compute time and final rendered scenes in our project. We optimized many of these general ideas as well and cut down our compute time, as well as increased our ability to render complex images.</span></p><p class="c0"><span class="c2"></span></p><hr><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c4">Part I: Ray Generation and Scene Intersection</span></p><p class="c1"><span class="c2">A ray is a small indice of light that is physically modeled to move in a straight line through air, where when it encounters &ldquo;shiny&rdquo; materials it reflects (pi - radians angle of incidence), and when it encounters different mediums it bends as well. This means we can represent any ray as a point of origin and a direction which changes with time, and thus we can begin to model our rays in our computer program. We started simply by transforming the input to the camera coordinate system, using simple geometry between our point and camera point, and then creating a Ray from our position to our camera. </span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">We can obtain our result with the triangle intersection algorithm of (1-b1-b2,b1,b2) as our barycentric coordinates, and intersect it with the points of P0, P1, P2 and solve our equations for the ray equation of O + t*D which gives us a minimum of the ray (O, the camera&#39;s clipping coordinates) and a &ldquo;maximum&rdquo; O+D. in the given time t. If our t is hit between our minimum and maximum then we intersect our triangle and store the information of the normal at the intersection, the primitive we have hit (triangle), and our BDSF.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">For ray sphere intersection our problem is finding the point where a ray intersects a sphere in three dimensions, if such a point exists. One of the simplest algorithms for solving this problem is based on finding the distance between the center of the sphere and the ray. If that distance is larger than the radius of the sphere, then there is no intersection. Otherwise, there are one or two points of intersection, which can be found by solving a quadratic equation. We take the origin (O) and direction (D) of our ray, and a sphere with radius (R) and center (C), and then we compute a scalar Tca = L &middot; D, where &middot; denotes dot product. This scalar tells us how far along D we need to go from O to reach the projection of C on the ray. If Tca is negative, we can reject the ray as pointing away from the sphere. Otherwise, we compute another scalar D2 = L &middot; L - Tca * Tca, where * denotes multiplication. This scalar tells us how far away C is from the ray (squared). If D2 is greater than R * R, we can reject the ray as missing the sphere. Otherwise, we compute another scalar Thc = sqrt(R * R - D2), where sqrt denotes square root. This scalar tells us how far along D we need to go from the projection of C on either side to reach the intersection points on the sphere. We can then compute two scalars T0 = Tca - Thc and T1 = Tca + Thc that tell us how far along D we need to go from O to reach the intersection points on the sphere. If both T0 and T1 are positive, then there are two points of intersection at O + T0 * D and O + T1 * D. If only one of them is positive, then there is one point of intersection at O + max(T0, T1) * D. If both are negative, then there is no intersection.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">The start of the rendering pipeline begins with the so-called &ldquo;pinhole camera model&rdquo;. We simulate how light rays would enter a camera by defining the camera as a point, or a pinhole, and then giving our pinhole camera a camera position, look up point, up vector, field view angle, and aspect ratio. This allows us to define parameters for any pixel needed on the screen. We then define light as a ray with a start and a direction, and we use them to test for intersection. Testing for intersections becomes costly, so we develop methods to reduce computation like Bounding Volume Hierarchies, k-d trees, and spatial hashing. With these methods we split our scene up into smaller regions to eliminate non productive regions and focus on areas that will actually be reached by our rays and our camera. </span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c3 c5">Normal shading examples (Banana, CBempty, CBspheres):</span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 409.50px; height: 307.13px;"><img alt="" src="images/image19.png" style="width: 409.50px; height: 307.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 409.50px; height: 307.13px;"><img alt="" src="images/image3.png" style="width: 409.50px; height: 307.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 413.50px; height: 310.13px;"><img alt="" src="images/image8.png" style="width: 413.50px; height: 310.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><hr><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c4">Part II: Bounding Volume Hierarchy</span></p><p class="c1"><span class="c2">BVH, or bounding volume hierarchy is a data structure that divides geometric primitives in a scene into a tree of bounding boxes which enclose the objects. We start by storing all our nodes in a single giant bounding box which we call the root, and then store values in it. If we exceed a max primitive number, we split our node into two separate leaf nodes under it. The way you split the image into bounding boxes is through a heuristic, which could be based on number of edges, or spatial median splitting, which is where you split on the longest median of the bounding box, which is what we used. We implemented our tree recursively.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">We then implemented a BVH intersection algorithm by testing a ray against each primitive in a leaf node, and returning the closest intersection. If we encounter an internal node, we test it on a bounding box, and if we don&rsquo;t intersect with the bounding box, we just ignore that branch of the tree, and continue. Thus we have found where the rays intersect with objects in the BVH tree.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Analysis:</span></p><p class="c1"><span class="c3">After implementing BVH trees, our rendering time was noticeably faster, especially with complex geometry. Our cow, for example, took us a few minutes to render without BVH trees, but once implemented, we rendered it in barely a few seconds, and for the other it went from 13 to less than a second. This is due to the ease of eliminating upper nodes in our BVH tree if a ray does not intersect that area, saving us an exponential amount of time by not doing its children&rsquo;s computation.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c5 c3">Before &amp; after comparisons</span></p><p class="c0"><span class="c5 c3"></span></p><p class="c1"><span class="c2">The cow:</span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 351.34px; height: 263.51px;"><img alt="" src="images/image31.png" style="width: 351.34px; height: 263.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 435.50px; height: 173.96px;"><img alt="" src="images/image17.png" style="width: 435.50px; height: 173.96px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.50px; height: 176.61px;"><img alt="" src="images/image33.png" style="width: 434.50px; height: 176.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Max Planck:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.50px; height: 300.38px;"><img alt="" src="images/image7.png" style="width: 400.50px; height: 300.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 492.55px; height: 192.15px;"><img alt="" src="images/image16.png" style="width: 492.55px; height: 192.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 494.50px; height: 191.67px;"><img alt="" src="images/image23.png" style="width: 494.50px; height: 191.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><hr><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c4">Part III: Direct Illumination</span></p><p class="c1"><span class="c2">The direct lighting function is a method in graphics to cast illumination from a fixture to an object. It is commonly used to grant images a greater sense of depth and realism. The types of direct lighting are Uniform Hemisphere lighting and Light Sampling. Uniform hemisphere sampling creates an estimation on a point by sampling on a hemisphere around that point, which is simple, but does not take into account the position or shape of the light source, and can produce noise results. Light sampling, on the other hand, is where we sample light directly from the light source and only retains relevant samples, which allows for less variation in lighting and reduces variance in our soft shadows.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">For hemisphere lighting &nbsp;we first calculate the density function of our 1/2pi, and for num_samples we take a vector sample and convert it to our world coordinates. Then we take our BVH tree and create a ray from our data and see if it intersects with the BVH tree, and if so calculate the incoming radiance. We then use monte carlo estimation and multiply our incoming radiance with a cosine term as well as by the BDSF term, and divide it by our density function.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">For Light Sampling, since we are using the actual light source unlike with hemisphere lighting, we iterate over all the light sources in the scene. We then take the probability function of every light source and sample as many times as are given, unless it&#39;s a delta light source, in which case each light ray will be the same, so we count it only once. We then take the probability density function, world coordinates (checking if Z coord isn&rsquo;t negative since otherwise the light source would be behind us), and cast a shadow ray to see if any other object is blocking our point. Then we accumulate the irradiance for the point, again multiplying by the cosine term as well as by the BDSF term, and dividing it by our density function.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Analysis:</span></p><p class="c1"><span class="c2">Based on our renderings, Uniform hemisphere sampling and light sampling produce slightly different results in terms of efficiency, quality, and smoothness. Uniform hemisphere sampling generally tends to produce more noise, especially where there are soft shadows or complex lighting in the scene. This is due to the fact that many of the samples we create end up not amounting to anything in terms of illumination. Light Sampling, on the other hand, produces more smoother and realistic scenes, since most of our calculations do contribute to the final illumination of the scene. However, light sampling also has some drawbacks, such as being more prone to aliasing or missing some subtle effects due to the discrete nature of the light source. Uniform hemisphere sampling is inefficient since it samples uniformly from a hemisphere around the normal vector, regardless of the actual position and shape of the light source, which means that most of the samples do not hit the light source and are wasted. Light sampling is more efficient because it samples directly from the light source, which means that all of the samples contribute to the illumination. However, light sampling also has some overhead costs, such as computing the probability density function (pdf) and performing visibility tests for each sample.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Examples:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image5.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 480.00px;"><img alt="" src="images/image32.png" style="width: 480.00px; height: 480.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image6.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c5 c3"></span></p><p class="c1"><span class="c2">Bunny with 1, 4, 16, 64 light ray samples and 1 sample per pixel:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image25.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image15.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image26.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image28.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><hr><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c4">Part IV: Global Illumination</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Indirect lighting is a technique used to simulate the illumination at a point generated by reflective surfaces, i.e. more than one bounce of light, which allows our scene to look more soft and realistic. We can use ray tracing to implement this portion of the project, but that takes a long time to render. Our first task is to implement indirect lighting with 0 bounces, or just the light that goes from the light source to the camera. Next we calculate the radiance of one bounce of light, and recursively calculate for more than one bounce, using russian roulette to terminate sampling, for efficiency. For russian roulette we continue with a chance of about .7, and continue sampling with another bounce until we reach the camera or we run out of bounces. We also have to check if the probability density function is 0, and if so terminate, and if our max ray depth is greater than 1. Then we accumulate the irradiance for the point, again multiplying by the cosine term as well as by the BDSF term, and dividing it by our density function (with russian roulette we divide by chance of continuing).</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Examples:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 406.00px; height: 304.50px;"><img alt="" src="images/image29.png" style="width: 406.00px; height: 304.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 404.50px; height: 303.38px;"><img alt="" src="images/image35.png" style="width: 404.50px; height: 303.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Only direct vs indirect illumination (respectively, for spheres):</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image18.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image11.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">CB bunny with 0, 1, 2, 3, and 100 max ray depth respectively:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image27.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image36.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image14.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image24.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Spheres with 1, 2, 4, 8, 16, 64, and 1024 samples per pixel respectively, 4 light rays:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image10.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image22.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image34.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image13.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image2.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image1.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image12.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><hr><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c4">Part V: Adaptive Sampling</span></p><p class="c1"><span class="c2">Adaptive sampling is a method that allows you to change your sampling amount as your sample based on the data collected on complexity and importance of certain regions, which allows for optimal solutions and reduces data costs. In our implantation we want to take pixels that converge quickly and reduce the sampling of them, while other pixels require many samples to reduce noise and graininess in our scene, so we up the sampling there. To support adaptive sampling we change raytrace_pixel() and check using maxTolerance*miu, and using the formulas provided check if our pixel has converged. We basically also define a min and max for each pixel (we don&rsquo;t want infinite just good enough), and then a threshold of acceptance (our max tolerance) and just sample over and over until we reach it, and output the final color we sampled.</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Majestic adaptive bunny + heatmap:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image4.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image30.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span class="c2">Also spheres + heatmap:</span></p><p class="c0"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image20.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image21.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>